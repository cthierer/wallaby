/**
 * @module wallaby/modules/auth/middlware/load-user
 */

import { userSession } from '../data-keys'

/**
 * Initialize middleware to load user information from a request's
 * Authorization header. The Authorization header must be in the format:
 *
 *  { provider } { session_token }
 *
 * Where `provider` is the name of the Oauth provider, and `sesion_token` is
 * the application token generated by the create-session middleware.
 *
 * When executed, the middleware will use the Authorization header to lookup
 * which user owns the session. The following state objects are set:
 *
 *  - `user`:
 *    - `id`: user profile ID.
 *    - `provider`: Oauth provider.
 *  - `session`:
 *    - `token`: session token parsed from the Authorization header.
 *    - `provider`: provider string parsed from the Authorization header.
 *
 * The application will stop execution and return a 401 status if there is no
 * Authorization header, or if the Authorization header cannot be linked to an
 * active session.
 *
 * @param {object} redis Initialized Redis client.
 * @param {integer} sessionDuration Number of seconds to extend a session when
 *  it is determined that the request matches an active session. If falsy, the
 *  session is not extended.
 * @returns {function} The middleware function.
 */
function initLoadUser(redis, sessionDuration) {
  return async function loadUser(ctx, next) {
    const headers = ctx.headers || {}
    const auth = headers.authorization || null
    const [provider, token] = auth && typeof auth.split === 'function'
      ? auth.split(' ')
      : []

    if (!provider || !token) {
      ctx.status = 401
      ctx.body = {
        status: 'error',
        code: 'auth:badHeader',
        message: 'Must provide a valid "Authorization" header'
      }
      return
    }

    const userId = await redis.getAsync(userSession(provider, token))

    if (!userId) {
      ctx.status = 401
      ctx.body = {
        status: 'error',
        code: 'auth:noSession',
        message: 'Create a session using the `GET /auth` endpoint'
      }
      return
    }

    ctx.state.user = {
      id: userId,
      provider
    }

    ctx.state.session = {
      token,
      provider
    }

    if (sessionDuration && sessionDuration > 0) {
      await redis.expireAsync(userSession(provider, token), sessionDuration)
    }

    await next()
  }
}

export default initLoadUser
